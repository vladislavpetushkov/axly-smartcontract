{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

#keys starts with SF means SwopFi
#keys starts with WX means Waves Exchange

##START CONSTANS##
let SF_POOL = "SF"
let WX_POOL = "WX"
let CAP_FEE_NO_LOAN = "capNoLoan"
let CAP_FEE_LOAN = "capLoan"
let STOPLOSS_FEE_NO_LOAN = "stopLossNoLoan"
let STOPLOSS_LOAN = "stopLossLoan"
let LOAN_FEE = "loan"
let NO_LOAN_FEE = "noLoan"
let NO_FEE = "noFee"
let SCALE8 = 100000000
let SCALE10 = 10000000000
let SCALE16 = toBigInt(10000000000000000)
let FEE_SCALE6 = 1000000
##END CONSTANS##

let kSFPoolAAssetBalance = "A_asset_balance" # balance A on swopfi
let kSFPoolBAssetBalance = "B_asset_balance" # balance B on swopfi
let kSFPoolAAssetId = "A_asset_id" # A asset id on swopfi
let kSFPoolBAssetId = "B_asset_id" # B asset id on swopfi
let kSFPoolShareId = "share_asset_id" # lp token id on swopfi
let kSFPoolShareSupply = "share_asset_supply" # lp supply on swopfi
let kSFPoolFee = "commission" #pool comission on swop.fi
let kUserPosition = "_userPosition" # with {POOLADDR}_{USERADDR}_{POSITION_NUMBER} prefix, amount shartokens in position staked by user in pool
let kUserPositionPool = "_userPositionPool" # with {USERADDR}_{POSITION_NUMBER} prefix, get pool by user position
let kUserBorrowAmount = "_userPositionBorrowAmount" # with {POOLADDR}_{USERADDR}_{POSITION_NUMBER} prefix, amount of borrowed tokens in position
let kUserBorrowAssetId = "_userPositionBorrowAssetId" # with {POOLADDR}_{USERADDR}_{POSITION_NUMBER} prefix, asset id of borrowed tokens in position
let kUserPositionNum = "_userPositionNumber" # with {USERADDR} prefix, user position nubmer in this pool
let kUserPositionInterest = "_userPositionInterest" # with with {POOLADDR}_{USERADDR}_{POSITION_NUMBER} prefix, user position interest
let kPoolTotal = "_poolTotal" # with {POOLADDR}_ prefix, total amount staked in pool by all users
let kPoolTotalLoan = "_poolTotalLoan" #with {POOLADDR}_ prefix, total amount staked in pool with  by all users 
let kPoolInterestLoan = "_poolInterestLoan" # with {POOLADDR}_ prefix, pool interest with loans
let kPoolInterestNoLoan = "_poolInterestNoLoan" # with {POOLADDR}_ prefix, pool interest with no loans
let kPoolCanBorrow = "_poolCanBorrow" # with {POOLADDR}_ prefix, can user get borrow in this pool
let kAxlyInFeeWithoutLoan = "_axlyFeeNoLoan" # with {POOLADDR} prefix
let kAxlyInFeeWithLoan = "_axlyFeeWithLoan" # with {POOLADDR} prefix
let kAxlyNoLoanCapFee = "_axlyFeeCapWithLoan" # with {POOLADDR} prefix
let kAxlyWithLoanCapFee = "_axlyFeeCapNoLoan" # with {POOLADDR} prefix
let kAxlyStopLossNoLoanFee = "_axlyFeeStoplossWithLoan" # with {POOLADDR} prefix
let kAxlyStopLossLoanFee = "_axlyFeeStoplossNoLoan" # with {POOLADDR} prefix
let kRequestId = "_request_id" # with request id prefix
let kRequestIter = "requests_iter" # currrent request number
let kPool = "pool_" # with {POOLADDR} postfix
let kSharePool = "_poolShareId" # with {SHARE_ASSET_ID} prefix
let kPoolCapChange = "_poolCapChange" # with {POOLADDR}_ prefix, amount of token(SWOP/WX) left after capitalization for next exchange
let kTokenLastPrice = "last_price" #last token prices in tx format: {A asset price},{B asset price},{LP asset price}(for backend)
let kPriceInOracle = "_twap5B" #with {ASSET_ID} prefix key for asset price in $ in price oracle 
let kActive = "active" # turn off/on all contract
let kActiveUsers = "activeUsers" # turn off/on contract for users
let kActiveSFWX = "_active" # with {TYPE} prefix, turn off/on swopfi/wx pools
let kPoolActive = "_activePool" # with {POOLADDR}_ prefix turn off/on pool
let kUserStopLoss = "_stopLoss" #with {POSITTION_ID}_{POOLADDR}_{ASSET_ID} prefix, price of token to withdrow position

let kMoneyBox = "axly_money_box"
let kSFFarmingAddr = "swopfi_farming_addr"
let kLendService = "lend_service_addr"
let kOperatorCallPK = "admin_call_pub_key"
let kPriceOracle = "price_oracle"
let kExContract = "exchange_contract"
let kWxSwapContract = "wx_swap_contract"
let kSwopId = "swop_id"
let kWxId = "wx_id"
let kAdmin1PK = "admin1_pub_key"
let kAdmin2PK = "admin2_pub_key"
let kAdmin3PK = "admin3_pub_key"


let moneyBox = Address(this.getString(kMoneyBox).valueOrErrorMessage("No axly moneyBox address").fromBase58String())
let exContract = Address(this.getString(kExContract).valueOrErrorMessage("No exchange contract address").fromBase58String())
let priceOracleAddr = Address(this.getString(kPriceOracle).valueOrErrorMessage("No price oracle address").fromBase58String())
let wxSwapContract = Address(this.getString(kWxSwapContract).valueOrErrorMessage("No wx swap address").fromBase58String())
let SWOPID = this.getString(kSwopId).valueOrErrorMessage("No swop id").fromBase58String()
let WXID = this.getString(kWxId).valueOrErrorMessage("No wx id").fromBase58String()
let admin1PK = this.getString(kAdmin1PK).valueOrErrorMessage("Can't get kAdmin1PK").fromBase58String()
let admin2PK = this.getString(kAdmin2PK).valueOrErrorMessage("Can't get kAdmin2PK").fromBase58String()
let admin3PK = this.getString(kAdmin3PK).valueOrErrorMessage("Can't get kAdmin3PK").fromBase58String()
let operatorPK = this.getString(kOperatorCallPK).valueOrErrorMessage("Can't get operatorPK").fromBase58String()

func unknownPoolType() = throw("Wrong pool type")

func getLendSrvAddr() = Address(this.getString(kLendService).valueOrErrorMessage("Can't get lend service addr").fromBase58String())

func isOperatorCall(i: Invocation) = if i.callerPublicKey == operatorPK then unit
        else throw("Only operator can call this function")

func isAdminCall(i: Invocation) = if i.callerPublicKey == admin1PK || i.callerPublicKey == admin3PK  then unit
        else throw("Only admin can call this function")

func isSelfCall(i: Invocation) = if i.caller == this then unit
        else throw("Only contract itself can call this function")

func isLandCall(i: Invocation) = if i.caller == getLendSrvAddr() then unit
        else throw("Only land contract can call this function")

func isActive() = if this.getBoolean(kActive).valueOrElse(true) == true then unit 
        else throw("DApp is inactive at this moment")

func isActiveForUsers() = 
  if 
    this.getBoolean(kActive).valueOrElse(true) &&
    this.getBoolean(kActiveUsers).valueOrElse(true) == true
  then 
      unit 
  else 
    throw("DApp is inactive for users at this moment")

func isPoolActive(pool: String, type: String) = {
  let WXSFActive = this.getBoolean(type + kActiveSFWX).valueOrElse(true)
  let poolActive = this.getBoolean(pool + kPoolActive).valueOrElse(true)
  if  WXSFActive && poolActive then true else false
}

func accountBalance(assetId: ByteVector|Unit) = match assetId {
    case id: ByteVector => this.assetBalance(id)
    case waves: Unit => this.wavesBalance().available
}

# get balances on swopfi
func getSFPoolBalances(poolAddr: Address) = (
    poolAddr.getInteger(kSFPoolAAssetBalance).valueOrErrorMessage("Can't get pool A asset balance"),
    poolAddr.getInteger(kSFPoolBAssetBalance).valueOrErrorMessage("Can't get pool B asset balance")
)

# get balances on wx
func getWXPoolBalances(poolAddr: Address, aId: String, bId: String) = (
  poolAddr.invoke("getAccBalanceWrapperREADONLY", [aId], []).exactAs[Int],
  poolAddr.invoke("getAccBalanceWrapperREADONLY", [bId], []).exactAs[Int]
)

# get pool balances
func getPoolBalances(poolAddr: Address, type:String, aId: String, bId: String) = {
  if type == SF_POOL then
    getSFPoolBalances(poolAddr)
  else if type == WX_POOL then
    getWXPoolBalances(poolAddr, aId, bId)
  else
    unknownPoolType()
}

# get pool data on swopfi
func getSFPoolData(poolAddr: Address) = {
  strict (balA, balB) = getSFPoolBalances(poolAddr)
  (
    poolAddr.getString(kSFPoolAAssetId).valueOrErrorMessage("Can't get pool A asset id"),
    poolAddr.getString(kSFPoolBAssetId).valueOrErrorMessage("Can't get pool B asset id"),
    balA,
    balB,
    poolAddr.getString(kSFPoolShareId).valueOrErrorMessage("Can't get share asset id")
  )
}

# get pool data on wx
func getWXPoolData(poolAddr: Address) = (
  strict cfg = poolAddr.invoke("getPoolConfigWrapperREADONLY", [], []).exactAs[List[Any]]
  let aId = cfg[4].as[String].valueOrErrorMessage("Can't get pool A asset id")
  let bId = cfg[5].as[String].valueOrErrorMessage("Can't get pool B asset id")
  let shareId = cfg[3].as[String].valueOrErrorMessage("Can't get pool LP asset id")
  strict (balA, balB) = getWXPoolBalances(poolAddr, aId, bId)
  (aId, bId, balA, balB, shareId)
)

func getPoolData(poolAddr: Address, type:String) = {
  if type == SF_POOL then
    getSFPoolData(poolAddr)
  else if type == WX_POOL then
    getWXPoolData(poolAddr)
  else
    unknownPoolType()
}

func getShareSupply(poolAddr: Address, type:String, shareId: String) = {
   if type == SF_POOL then
    poolAddr.getInteger(kSFPoolShareSupply).valueOrErrorMessage("Can't get share asset supply")
  else if type == WX_POOL then
    assetInfo(shareId.fromBase58String()).valueOrErrorMessage("Wrong ShareId").quantity
  else
    unknownPoolType()
}

func getPoolTotalShare(pool: String) = this.getInteger(pool + kPoolTotal).valueOrElse(0)

func getPoolTotalShareWithLoan(pool: String) = this.getInteger(pool + kPoolTotalLoan).valueOrElse(0)

func getNewUserPositionNumber(user:String) = this.getInteger(user + kUserPositionNum).valueOrElse(0) + 1

func getAxlyFee(pool: String, feeType: String) = {
  if feeType == CAP_FEE_LOAN then 
     this.getIntegerValue(pool + kAxlyWithLoanCapFee)
  else if feeType == CAP_FEE_NO_LOAN then 
     this.getIntegerValue(pool + kAxlyNoLoanCapFee)
  else if feeType == LOAN_FEE then 
    this.getIntegerValue(pool + kAxlyInFeeWithLoan)
  else if feeType == NO_LOAN_FEE then
    this.getIntegerValue(pool + kAxlyInFeeWithoutLoan)
  else if feeType == NO_FEE then 
    0
  else
    throw("Wrong fee type")
}

func getSFFarmingAddr() = Address(this.getString(kSFFarmingAddr).valueOrErrorMessage("Can't get swopfi farming addr").fromBase58String())

func getWXFarmingAddr(poolAddr: Address) = {
  let fContract = poolAddr.getString("%s__factoryContract").valueOrErrorMessage("Can't get WX factory contract addr").fromBase58String().Address()
  let factroyCfg = fContract.getString("%s__factoryConfig").valueOrErrorMessage("Can't get WX factory cfg").split("__")
  Address(factroyCfg[1].fromBase58String())
} 

func assetIdToStr(assetId: Any ) = match assetId {
    case id: ByteVector => id.toBase58String()
    case waves: Unit => "WAVES"
    case _ => throw("Not Asset id")
}

func assetIdFromStr(assetId: String) = if assetId == "WAVES" then unit else assetId.fromBase58String()

func getAssetDecimals(assetId: String) = if assetId == "WAVES" then 8 else match assetInfo(assetId.fromBase58String()) {
    case asset:Asset =>
        asset.decimals
    case _ => throw("Can't find asset")
}

func getAssetPrecition(assetId: String) = pow(10, 0, getAssetDecimals(assetId), 0, 0, DOWN)

func getAssetsPrice(assetIds: List[String]) = {
  func getPrices(a: List[Int], assetId:String) = {
    let assetPrice = priceOracleAddr.getIntegerValue(assetId + kPriceInOracle)
    (a :+ assetPrice)
  }
  FOLD<50>(assetIds, [], getPrices)
}

func getSharePrice(shareId: String) = {
  let pool = this.getString(shareId + kSharePool).valueOrErrorMessage("Can't find pool addr by share id")
  let poolAddr = pool.fromBase58String().Address()
  let pType = this.getString(kPool + pool).valueOrErrorMessage("Pool is not inited")
  let (aId, bId, aBalance, bBalance) = getPoolData(poolAddr, pType)
  let dPriceA = priceOracleAddr.getIntegerValue(aId + kPriceInOracle)
  let dPriceB = priceOracleAddr.getIntegerValue(bId + kPriceInOracle)
  let shareSupply = getShareSupply(poolAddr, pType, shareId)
  let APrecision = pow(10, 0, getAssetDecimals(aId), 0, 0, DOWN)
  let BPrecision = pow(10, 0, getAssetDecimals(bId), 0, 0, DOWN)
  let sharePrecision = pow(10, 0, getAssetDecimals(shareId), 0, 0, DOWN)
  let sum = fraction(aBalance, dPriceA, APrecision) + fraction(bBalance, dPriceB, BPrecision)
  fraction(sum, sharePrecision, shareSupply)
}

func getSharePrices(shareIds: List[String]) = {
  func getPrices(a: List[Int], shareId:String) = {
    a :+ getSharePrice(shareId)

  }
  FOLD<20>(shareIds, [], getPrices)
}

func getCursEntries(aId: String, bId: String, shareId: String, wAmounts: List[String]) = {
  let assetsPrices = getAssetsPrice([aId, bId])
  let sharePrice = getSharePrice(shareId)
  let prices = [assetsPrices[0].toString(), assetsPrices[1].toString(), sharePrice.toString()] ++ wAmounts
  [
    StringEntry(kTokenLastPrice, prices.makeString(","))
  ]
}

func calcReplenishByTwoTokens(pType: String, poolAddr: Address, pmtA: Int, aId: String, pmtB: Int, bId: String, balA: Int, balB: Int) = {
  if pType == SF_POOL then 
    strict repl = poolAddr.invoke("callFunction", ["calcLPReplenishTwoTokensREADONLY", [pmtA.toString(), pmtB.toString()]], nil).exactAs[List[Any]]
    (repl[3].exactAs[Int], repl[4].exactAs[Int], repl[1].exactAs[Int], repl[2].assetIdToStr(), repl[0].exactAs[Int])
  else if pType == WX_POOL then
    strict (evalPutInA, evalPutInB) = 
      (
        poolAddr.invoke("evaluatePutByAmountAssetREADONLY", [pmtA], []).exactAs[String].split("__"),
        poolAddr.invoke("evaluatePutByPriceAssetREADONLY", [pmtB], []).exactAs[String].split("__")
      )
    let lpInA = evalPutInA[1].parseIntValue()
    let lpInB = evalPutInB[1].parseIntValue()
    if  lpInA < lpInB then
      let pmt = evalPutInA[8].parseIntValue()
      (pmtA, pmt, pmtB - pmt, bId, lpInB)
    else
      let pmt = evalPutInB[7].parseIntValue()
      (pmt, pmtB, pmtA - pmt, aId, lpInA) 
  else unknownPoolType()
}

func replenishTwoTokensByType(poolAddr: Address, pType: String, pmtA:Int, aId:String, pmtB:Int, bId:String) = {
  let payments = [
    AttachedPayment(aId.assetIdFromStr(), pmtA), 
    AttachedPayment(bId.assetIdFromStr(), pmtB)
  ]
  if pType == SF_POOL then 
    poolAddr.invoke("callFunction", ["replenishWithTwoTokens", ["false", "0"]], payments)
  else if pType == WX_POOL then
    poolAddr.invoke("put", [1000000, false], payments)
  else unknownPoolType()
}

func replenishOneTokenByType(poolAddr: Address, pType: String, pmt:Int, pmtId:String) = {
  let payments = [AttachedPayment(pmtId.assetIdFromStr(), pmt)]
  if pType == SF_POOL then 
    poolAddr.invoke("callFunction", ["replenishWithOneToken", ["0", "false", "0"]], payments)
  else if pType == WX_POOL then
    poolAddr.invoke("putOneTkn", [0, false], payments)
  else unknownPoolType()
}

func stakeLP(pool: String, pType: String, shareId: String, amount: Int) = { 
  let payments = [AttachedPayment(shareId.fromBase58String(), amount)]
  if pType == SF_POOL then
    getSFFarmingAddr().invoke("lockShareTokens", [pool, 0], payments)
  else if pType == WX_POOL then
    getWXFarmingAddr(pool.addressFromStringValue()).invoke("stake", nil, payments)
  else unknownPoolType()
}

func unstakeLP(pool: String, pType: String, shareId: String, amount: Int) = {
  let (farmAddr, fName, params) = 
    if pType == SF_POOL then
      (
        getSFFarmingAddr(),
        "withdrawShareTokens",
        [pool, amount]
      )
    else if pType == WX_POOL then 
      (
        getWXFarmingAddr(pool.fromBase58String().Address()),
        "unstake",
        [shareId, amount]
      )
    else 
      unknownPoolType()
    strict inv = invoke(farmAddr, fName, params, nil)
  amount
}

func calcAmountToPaySF(pool: String, assetIdA:String, assetIdB:String, balA:Int, balB:Int, amountTokenToGet: Int, assetTokenToGet: String) = {
  let poolAddr = pool.fromBase58String().Address()
  let feeScale6 = 1000000
  let fee = poolAddr.getIntegerValue(kSFPoolFee)
  let amntGetNoFee = amountTokenToGet.fraction(feeScale6, feeScale6 - fee, CEILING)
  let (amountToPay, assetToPay) = 
    if assetTokenToGet == assetIdA then
      let amountToPay = amntGetNoFee.fraction(balB, balA - amntGetNoFee, CEILING)
      (amountToPay, assetIdB)
    else
      let amountToPay = amntGetNoFee.fraction(balA, balB - amntGetNoFee, CEILING) 
      (amountToPay, assetIdA)
    (assetToPay, amountToPay)
}

func getWXSwapFees(pool: String) = {
  let poolAddr = pool.addressFromStringValue()
  let fContract = poolAddr.getString("%s__factoryContract").valueOrErrorMessage("Can't get WX factory contract addr").addressFromStringValue()
  let poolFeeDefault = wxSwapContract.getInteger("%s__poolFee").value()
  let protocolFeeDefault = wxSwapContract.getInteger("%s__protocolFee").value()
  match fContract.invoke("getSwapFeeREADONLY", [poolAddr.toString()], []) {
    case fees: (Int, Int) => (fees._1, fees._2)
    case _ => (poolFeeDefault, protocolFeeDefault)
  }
}

func calcAmountToPayWX(pool: String, assetIdA:String, assetIdB:String, balA:Int, balB:Int, amountTokenToGet: Int, assetTokenToGet: String) = {
  let (pFee, prFee) = getWXSwapFees(pool)
  let feeScale = toBigInt(100000000)
  let (amountToPay, assetToPay) = 
    if assetTokenToGet == assetIdA then
        let amountToPay = amountTokenToGet.fraction(balB, balA - amountTokenToGet)
        (amountToPay, assetIdB)
    else
      let amountToPay = amountTokenToGet.fraction(balA,  balB - amountTokenToGet)
      (amountToPay, assetIdA)
  let amountToPayWithFee = toBigInt(amountToPay).fraction(feeScale, feeScale - toBigInt(prFee + pFee), CEILING).toInt()
  (assetToPay, amountToPayWithFee)
}

func exchangeDirectly(pType: String, pool: String, assetIdA:String, assetIdB:String, balA:Int, balB:Int, amountTokenToGet: Int, assetTokenToGet: String) = {
  if pType == SF_POOL then
    let (assetToPay, amountToPay) = calcAmountToPaySF(pool, assetIdA, assetIdB, balA, balB, amountTokenToGet, assetTokenToGet)
    pool.addressFromStringValue().invoke("callFunction", ["exchange", [amountTokenToGet.toString()]], [AttachedPayment(assetToPay.assetIdFromStr(), amountToPay)])
  else if pType == WX_POOL then
    let (assetToPay, amountToPay) = calcAmountToPayWX(pool, assetIdA, assetIdB, balA, balB, amountTokenToGet, assetTokenToGet)
    wxSwapContract.invoke("swap", [amountTokenToGet, assetTokenToGet, this.toString()], [AttachedPayment(assetToPay.assetIdFromStr(), amountToPay)])
  else unknownPoolType()
}

func calcWithdrawLPFromPoolVirt(poolAddr:Address, pType: String, shareId: String, userCanWithdraw:Int) = {
  let (amountA, amountB) = 
    if pType == SF_POOL then 
      strict inv = poolAddr.invoke("callFunction", ["withdrawREADONLY", [userCanWithdraw.toString()]], []).exactAs[List[Any]]
      (inv[0].exactAs[Int], inv[1].exactAs[Int])
    else if pType == WX_POOL then
      strict inv = poolAddr.invoke("evaluateGetREADONLY", [shareId, userCanWithdraw], []).exactAs[String].split("__")
      (inv[1].parseIntValue(), inv[2].parseIntValue())
    else unknownPoolType()
  (amountA, amountB)
  
}

#claim tokens [Swop, WX] from farming
func claimFarmed(pType: String, pool: String, lpId: String) = {
  if pType == SF_POOL then 
    strict balBefore = accountBalance(SWOPID)
    strict inv = getSFFarmingAddr().invoke("claim", [pool], [])
    let balAfter = accountBalance(SWOPID)
    (balAfter - balBefore, SWOPID)
  else if pType == WX_POOL then 
    strict balBefore = accountBalance(WXID)
    strict inv = getWXFarmingAddr(pool.fromBase58String().Address()).invoke("claimWx", [lpId], [])
    let balAfter = accountBalance(WXID)
    (balAfter - balBefore, WXID)
  else unknownPoolType()
}

# function check pool type (SF or WX) and replenish it
func replenishByType(
  pType: String,  
  pool: String,
  feeType: String, 
  pmtA: Int, 
  aId: String, 
  pmtB: Int, 
  bId: String, 
  balA: Int, 
  balB: Int, 
  LPId: String) = {

  strict lpBalanceBefore = accountBalance(LPId.fromBase58String())
  let poolAddr = pool.addressFromStringValue()
  let (change, changeId) = 
    if pmtA > 0 && pmtB > 0 then 
      let (pmtInA, pmtInB, change, changeId) = calcReplenishByTwoTokens(pType, poolAddr, pmtA, aId, pmtB, bId, balA, balB)
      strict inv = poolAddr.replenishTwoTokensByType(pType, pmtInA, aId, pmtInB, bId)
      (change, changeId)
    else if pmtA > 0 then
      (pmtA, aId)
    else if pmtB > 0 then
      (pmtB, bId)
    else throw("pmts must be > 0")
  
  strict inv =  
    if change > 0 then
      poolAddr.replenishOneTokenByType(pType, change, changeId)
    else
      nil

  let lpBalanceAfter = accountBalance(LPId.fromBase58String())
  let totalStaked = lpBalanceAfter - lpBalanceBefore
  let axlyFeeAmount = fraction(totalStaked, getAxlyFee(pool, feeType), FEE_SCALE6)
  let userShareForStake = totalStaked - axlyFeeAmount

  if userShareForStake <= 0 then throw("amount of staked sharetokens must be > 0") else

  strict invLP = stakeLP(pool, pType, LPId, userShareForStake)
  (userShareForStake, axlyFeeAmount)
}

# calc replenish enteries
func replenishEntries(pool: String, user: String, stakedAmount: Int, axlyFeeAmount: Int, posNum: Int,  shareId:String, type: String, withLoan: Boolean) = {
  let totalAmount = getPoolTotalShare(pool)
  let totalAmountLoan = getPoolTotalShareWithLoan(pool)
  let (curPoolInterest, totalStakedWithLoan) = 
    if withLoan then 
      (this.getIntegerValue(pool + kPoolInterestLoan), totalAmountLoan + stakedAmount)
    else 
      (this.getIntegerValue(pool + kPoolInterestNoLoan), totalAmountLoan)
  [
    IntegerEntry(pool + kPoolTotal, totalAmount + stakedAmount),
    IntegerEntry(pool + kPoolTotalLoan, totalStakedWithLoan),
    IntegerEntry(pool + "_" + user + "_" + posNum.toString() + kUserPosition, stakedAmount),
    IntegerEntry(pool + "_" + user + "_" + posNum.toString() + kUserPositionInterest, curPoolInterest),
    StringEntry(user + "_" + posNum.toString() + kUserPositionPool, pool),
    IntegerEntry(user + kUserPositionNum, posNum),
    
    ScriptTransfer(moneyBox, axlyFeeAmount, shareId.fromBase58String())
  ]
}

#exchange keeper
func exchangeKeeper(
  toToken: String,
  pmtAmount: Int, 
  pmtAsset: ByteVector,
  amountsIn: List[Int], 
  addresses: List[String], 
  assetsToReceive: List[String], 
  estReceived: List[Int], 
  slippageTolerance: Int, 
  minReceived: Int, 
  options: List[String]
) = {
  strict tokenBalanceBefore = accountBalance(toToken.assetIdFromStr())
  strict inv = exContract.invoke("swap", [amountsIn, addresses, assetsToReceive, estReceived, slippageTolerance, minReceived, options], [AttachedPayment(pmtAsset, pmtAmount)])
  accountBalance(toToken.assetIdFromStr()) - tokenBalanceBefore 
}

#exchange on puzzle
func exchangePuzzle(
  toToken: String,
  pmtAmount: Int, 
  pmtAsset: ByteVector,
  routesStr: String, 
  minToReceive: Int,
  options: List[String]
) = {
  strict tokenBalanceBefore = accountBalance(toToken.assetIdFromStr())
  strict inv = exContract.invoke("puzzleSwap", [routesStr,minToReceive,options], [AttachedPayment(pmtAsset, pmtAmount)])
  accountBalance(toToken.assetIdFromStr()) - tokenBalanceBefore 
}

#exchange on swopfi
func exchangeSwopFi(
  toToken: String,
  pmtAmount: Int, 
  pmtAsset: ByteVector,
  exchangers: List[String],
  exchangersType: List[String],
  args1: List[String],
  args2: List[String],
  routingAssetsKeys: List[String],
  minAmountToReceive: Int,
  options: List[String]
) = {
  strict tokenBalanceBefore = accountBalance(toToken.assetIdFromStr())
  strict inv = exContract.invoke("swopfiSwap", [exchangers, exchangersType, args1, args2, routingAssetsKeys, minAmountToReceive, options], [AttachedPayment(pmtAsset, pmtAmount)])
  accountBalance(toToken.assetIdFromStr()) - tokenBalanceBefore
}

# capitalize
func capitalize(pool: String,  pType: String, tokenId: String, tokenAmount: Int) = {
  let poolAddr = pool.fromBase58String().Address()
  let (AId, BId, balA, balB, shareId) = getPoolData(poolAddr, pType)
  if tokenId != AId && tokenId != BId then throw("Wrong asset") else
  #replenish
  let (pmtA, pmtB) = if tokenId == AId then (tokenAmount, 0) else (0, tokenAmount)
  let (stakedAmount, nf) = replenishByType(pType, pool, NO_FEE, pmtA, AId, pmtB, BId, balA, balB, shareId)

  let curPoolInterestLoan = this.getInteger(pool + kPoolInterestLoan).valueOrElse(0)
  let curPoolInterestNoLoan = this.getInteger(pool + kPoolInterestNoLoan).valueOrElse(0)
  let totalShareAmount = getPoolTotalShare(pool)
  let totalShareAmountWithLoan = getPoolTotalShareWithLoan(pool)
  let loanPercent = fraction(totalShareAmountWithLoan, SCALE8, totalShareAmount)
  let stakedLoan = fraction(stakedAmount, loanPercent, SCALE8)
  let stakedNoLoan = stakedAmount - stakedLoan
  let newInterestLoan = if totalShareAmountWithLoan > 0 then 
      curPoolInterestLoan + fraction(stakedLoan, SCALE10, totalShareAmountWithLoan)
    else
      0
  let newInterestNoLoan = if totalShareAmount - totalShareAmountWithLoan > 0 then 
      curPoolInterestNoLoan + fraction(stakedNoLoan, SCALE10, totalShareAmount - totalShareAmountWithLoan)
    else 
      0
  let axlyFeeLoan = fraction(stakedLoan, getAxlyFee(pool, CAP_FEE_LOAN), FEE_SCALE6)
  let axlyFeeNoLoan = fraction(stakedNoLoan, getAxlyFee(pool, CAP_FEE_NO_LOAN), FEE_SCALE6)
  strict axlyFee = unstakeLP(pool, pType, shareId, axlyFeeLoan + axlyFeeNoLoan)
  [
    IntegerEntry(pool + kPoolInterestLoan, newInterestLoan),
    IntegerEntry(pool + kPoolInterestNoLoan, newInterestNoLoan),
    IntegerEntry(pool + kPoolTotal, totalShareAmount + stakedAmount - axlyFee),
    IntegerEntry(pool + kPoolTotalLoan, totalShareAmountWithLoan + stakedLoan - axlyFeeLoan),
    ScriptTransfer(moneyBox, axlyFeeLoan + axlyFeeNoLoan, shareId.fromBase58String())
  ] ++ getCursEntries(AId, BId, shareId, [])
}

func userCanWithdrawShareCalc(user: String, pool:String, posId: String, borrowed: Boolean) = {
  let pAmount = this.getInteger(pool + "_" + user + "_" + posId + kUserPosition).valueOrErrorMessage("Unknown position")
  let userInterest = this.getIntegerValue(pool + "_" + user + "_" + posId + kUserPositionInterest)
  let poolInterest = if borrowed then
      this.getIntegerValue(pool + kPoolInterestLoan)
    else 
      this.getIntegerValue(pool + kPoolInterestNoLoan)
  pAmount + fraction(pAmount, poolInterest - userInterest, SCALE10)
}

func calcStopLossFee(pool: String, isBorrowed: Boolean, stopLoss: Boolean, lpWithdraw: Int) = {
  let feeType = if isBorrowed then STOPLOSS_LOAN else STOPLOSS_FEE_NO_LOAN
  if stopLoss then fraction(lpWithdraw, getAxlyFee(pool, feeType), FEE_SCALE6) else 0
}

func withdrawToUser(user: String, pool:String, posId: String, stopLoss: Boolean) = {
  let pAmount = this.getInteger(pool + "_" + user + "_" + posId + kUserPosition).valueOrErrorMessage("Unknown position")
  let isBorrowed = this.getInteger(pool + "_" + user + "_" + posId + kUserBorrowAmount).valueOrElse(0) > 0
  let userCanWithdraw = userCanWithdrawShareCalc(user, pool, posId, isBorrowed)
  let poolTotalShare = getPoolTotalShare(pool)
  let userAddr = user.fromBase58String().Address()
  let poolAddr = Address(pool.fromBase58String())
  let pType = this.getString(kPool + pool).valueOrErrorMessage("Unknown pool")
  let (idAStr, idBStr, balA, balB, shareId) = getPoolData(poolAddr, pType)
  let (idA, idB) = (idAStr.assetIdFromStr(), idBStr.assetIdFromStr())
  let stopLossFee = calcStopLossFee(pool, isBorrowed, stopLoss, userCanWithdraw)

  strict cBalABefore = accountBalance(idA)
  strict cBalBBefore = accountBalance(idB)

  strict inv =  
    if pType == SF_POOL then 
      strict inv = unstakeLP(pool, pType, shareId, stopLossFee)
      poolAddr.invoke("callFunction", ["withdraw", [userCanWithdraw.toString()]], []) 
    else if pType == WX_POOL then
      strict inv = unstakeLP(pool, pType, shareId, userCanWithdraw + stopLossFee)
      poolAddr.invoke("get", [], [AttachedPayment(shareId.assetIdFromStr(), userCanWithdraw)]) 
    else unknownPoolType()

  strict cBalAAfter = accountBalance(idA)
  strict cBalBAfter = accountBalance(idB)

  let (tokensAmountA, tokensAmountB) = (cBalAAfter - cBalABefore, cBalBAfter - cBalBBefore)
  let (toUserA, toUserB) = 
    if isBorrowed then 
      let borrowAsset = this.getStringValue(pool + "_" + user + "_" + posId + kUserBorrowAssetId)
      strict debt = getLendSrvAddr().invoke("getAssetDebt", [false, user + "_" + posId, borrowAsset], []).exactAs[Int]
      
      let amountToGetEx = 
        if borrowAsset == idAStr && debt > tokensAmountA then 
          debt - tokensAmountA
        else if borrowAsset == idBStr && debt > tokensAmountB then
          debt - tokensAmountB
        else 0
      strict exInv = if amountToGetEx > 0 then exchangeDirectly(pType, pool, idAStr, idBStr, balA - tokensAmountA, balB - tokensAmountB, amountToGetEx, borrowAsset) else nil
      strict cBalAAfterRepay = accountBalance(idA)
      strict cBalBAfterRepay = accountBalance(idB)
      strict closeDbtInv = 
        if debt > 0 then 
          getLendSrvAddr().invoke("repayFor", [user + "_" + posId], [AttachedPayment(borrowAsset.assetIdFromStr(), debt)])  
        else
          0
      if borrowAsset == idAStr then
        (cBalAAfterRepay - cBalABefore - debt, cBalBAfterRepay - cBalBBefore)
      else
        (cBalAAfterRepay - cBalABefore, cBalBAfterRepay - cBalBBefore - debt)
    else
      (tokensAmountA, tokensAmountB)
  
  let entries = [
    DeleteEntry(pool + "_" + user + "_" + posId + kUserPosition),
    DeleteEntry(user + "_" + posId + kUserPositionPool),
    DeleteEntry(pool + "_" + user + "_" + posId + kUserBorrowAmount),
    DeleteEntry(pool + "_" + user + "_" + posId + kUserBorrowAssetId),
    DeleteEntry(pool + "_" + user + "_" + posId + kUserPositionInterest),
    IntegerEntry(pool + kPoolTotal, poolTotalShare - userCanWithdraw - stopLossFee),
    ScriptTransfer(userAddr, toUserA, idA),
    ScriptTransfer(userAddr, toUserB, idB),
    ScriptTransfer(moneyBox, stopLossFee, shareId.fromBase58String())
  ] ++ getCursEntries(idAStr, idBStr, shareId, [])
  (entries, [toUserA, toUserB])
}

func parseRequest(requestId: String) = {
  let request = this.getString(requestId + kRequestId).valueOrErrorMessage("No request with id " + requestId).split(",")
  let user = request[0]
  let pool = request[1]
  let pmtA = parseIntValue(request[2])
  let AId = request[3]
  let pmtB = parseIntValue(request[4])
  let BId = request[5]
  let balA = parseIntValue(request[6])
  let balB = parseIntValue(request[7])
  let shareId = request[8]
  let bwAsset = request[9]
  let bwAmount = parseIntValue(request[10])
  (user, pool, pmtA, AId, pmtB, BId, balA, balB, shareId, bwAsset, bwAmount)
}

func calcBorrowAmount(pmtA: Int, pmtB: Int, aId: String, bId: String, leverage: Int, borrowId: String) = {
  if borrowId != aId && borrowId != bId then throw("Wrong borrow asset") else
  let dPriceA = priceOracleAddr.getIntegerValue(aId + kPriceInOracle)
  let dPriceB = priceOracleAddr.getIntegerValue(bId + kPriceInOracle)
  let decPrA = pow(10, 0, getAssetDecimals(aId), 0, 0, DOWN)
  let decPrB = pow(10, 0, getAssetDecimals(bId), 0, 0, DOWN)
  let paydInDollar = fraction(dPriceA, pmtA, decPrA) + fraction(dPriceB, pmtB, decPrB)
  let (borrowPrice, borrowDecPr) = if borrowId == aId then (dPriceA, decPrA) else (dPriceB, decPrB) 
  fraction(fraction(paydInDollar, leverage - 100, 100), borrowDecPr, borrowPrice) 
}

func parseReplenishPmts(pmts: List[AttachedPayment], AId: String, BId: String) = {
  if size(pmts) == 2 then
      if pmts[0].assetId.assetIdToStr() != AId then throw("Wrong payment asset A") else
      if pmts[1].assetId.assetIdToStr() != BId then throw("Wrong payment asset B") else
      (pmts[0].amount, pmts[1].amount)
    else if size(pmts) == 1 then
      if pmts[0].assetId.assetIdToStr() == AId then (pmts[0].amount, 0) else
      if pmts[0].assetId.assetIdToStr() == BId then (0, pmts[0].amount) else
      throw("Wrong payment")
    else throw("One or two payments expected")
}

func calcPriceImpact(balA:Int, balB:Int, newBalA:Int, newBalB:Int) = {
  let pri = (SCALE8 - fraction(balB.fraction(SCALE8, balA), SCALE8, newBalB.fraction(SCALE8, newBalA))) * 100
  if pri < 0 then pri * (-1) else pri
}

func claimAndCheckAmnt(pool: String, pType: String, claim: Boolean, amount: Int, change: Int) = {
  let poolLpId = this.getStringValue(pool + kSharePool)
  let (claimAmount, claimAsset) = 
  if claim then claimFarmed(pType, pool, poolLpId) 
  else 
    let claimedAsset = 
      if pType == SF_POOL then 
        SWOPID 
      else if pType == WX_POOL then
        WXID
      else unknownPoolType()
    (amount, claimedAsset)
  let bal = accountBalance(claimAsset)
  if amount > claimAmount + change || amount > bal  then throw("To big amount to exchange") else
  (claimAmount, claimAsset)
}

########READONLY FUNCTIONS############
@Callable(i)
func getShareAssetPriceREADONLY(shareId: String) = {
  let sharePrices = getSharePrice(shareId)
  ([], sharePrices)
}

@Callable(i)
func getUserPositionShareAmountREADONLY(user: String, posNum: String) = {
  let pool = this.getString(user + "_" + posNum + kUserPositionPool).valueOrErrorMessage("Unknown position")
  let borrowAmount = this.getIntegerValue(pool + "_" + user + "_" + posNum + kUserBorrowAmount)
  let userCanWithdraw = userCanWithdrawShareCalc(user, pool, posNum, borrowAmount > 0)
  ([], userCanWithdraw)
}

#max 20 pos
@Callable(i)
func getUserPositionREADONLY(user: String, pools: List[String], posNum: List[String]) = {
  func userPos(a: (List[Int], List[Int], List[Int], List[Int], List[Int], Int), pool: String) = {
    let (wAmountsA, wAmountsB, debts, eqWAmountsA, eqWAmountsB, index) = a
    if !this.getInteger(pool + "_" + user + "_" + posNum[index] + kUserPosition).isDefined() then (wAmountsA:+ 0, wAmountsB:+ 0, debts:+0, eqWAmountsA:+0, eqWAmountsB:+0, index + 1) else
    let pType = this.getString(kPool + pool).valueOrErrorMessage("Pool is not inited")
    let (AId, BId, balA, balB, shareId) = getPoolData(Address(pool.fromBase58String()), pType)
    let borrowAmount = this.getInteger(pool + "_" + user + "_" + posNum[index] + kUserBorrowAmount).valueOrElse(0)
    let userCanWithdraw = userCanWithdrawShareCalc(user, pool, posNum[index], borrowAmount > 0)
    let (wAmountA, wAmountB) = calcWithdrawLPFromPoolVirt(Address(pool.fromBase58String()), pType, shareId, userCanWithdraw)
    if borrowAmount > 0 then 
      let borrowAsset = this.getStringValue(pool + "_" + user + "_" + posNum[index] + kUserBorrowAssetId)
      strict debt = getLendSrvAddr().invoke("getAssetDebt", [false, user + "_" + posNum[index], borrowAsset], []).exactAs[Int]
      #Equity
      let (assetToPay, amountToPay) = 
        if pType == SF_POOL then
          calcAmountToPaySF(pool, AId, BId, balA, balB, debt, borrowAsset)
        else if pType == WX_POOL then
          calcAmountToPayWX(pool, AId, BId, balA, balB, debt, borrowAsset)
        else unknownPoolType()
      let (eqWAmountA, eqWAmountB) = if(assetToPay == BId) then (wAmountA - debt, wAmountB - amountToPay) else (wAmountA - amountToPay, wAmountB - debt)
      (wAmountsA:+ wAmountA, wAmountsB:+ wAmountB, debts:+ debt, eqWAmountsA:+eqWAmountA, eqWAmountsB:+eqWAmountB, index + 1)
    else
      (wAmountsA:+ wAmountA, wAmountsB:+ wAmountB, debts, wAmountsA:+ wAmountA, wAmountsB:+ wAmountB, index + 1)
  }
  let (wAmountsA, wAmountsB, debts, eqWAmountsA, eqWAmountsB) = FOLD<20>(pools, ([], [], [], [], [], 0), userPos)
  ([], (wAmountsA, wAmountsB, debts, eqWAmountsA, eqWAmountsB))
}
########END READONLY FUNCTIONS############


@Callable(i)
func replenish(pool: String, leverage: Int, borrowId: String) = isActiveForUsers().valueOrElse({
  let pType = this.getString(kPool + pool).valueOrErrorMessage("Pool is not inited")
  if !isPoolActive(pool, pType) then throw("Pool not active at this moment") else
  if leverage < 100 || leverage > 300 then throw("Leverage can't be <100 and >300") else
  if !this.getBooleanValue(pool + kPoolCanBorrow) && leverage > 100 then throw("You can't borrow in this pool") else

  let (AId, BId, balA, balB, shareId) = getPoolData(Address(pool.fromBase58String()), pType)
  if borrowId != AId && borrowId != BId then throw("Wrong borrow asset") else
  let (pmtA, pmtB) = parseReplenishPmts(i.payments, AId, BId)
  let user = i.caller.toString()
    
  let newPosNum = getNewUserPositionNumber(user)
  if leverage > 100 then 
    let borrowAmount = calcBorrowAmount(pmtA, pmtB, AId, BId, leverage, borrowId) 
    let request = makeString([
        user,
        pool,
        pmtA.toString(),
        AId,
        pmtB.toString(),
        BId,
        balA.toString(),
        balB.toString(),
        shareId,
        borrowId,
        borrowAmount.toString()
      ], ",")
    
    strict newRequestId = this.invoke("createNewRequest", [request], []).exactAs[Int]
    
    let args = [
      user + "_" + newPosNum.toString(),
      shareId,
      borrowId,
      borrowAmount,
      this.toString(),
      "replenishFromLand",
      newRequestId.valueOrErrorMessage("Can't create new request").toString()
    ]
    strict inv = getLendSrvAddr().reentrantInvoke("flashPosition", args, [])
    let userStaked = this.getIntegerValue(pool + "_" + user + "_" + newPosNum.toString() + kUserPosition)
    strict (newBalA, newBalB) = getPoolBalances(Address(pool.fromBase58String()), pType, AId, BId)
    let prImpact = calcPriceImpact(balA, balB, newBalA, newBalB)
    let (wAmountA, wAmountB) = calcWithdrawLPFromPoolVirt(Address(pool.fromBase58String()), pType, shareId, userStaked)
    ([], [prImpact, wAmountA, wAmountB])
  else
    strict (userStaked, axlyFee) = replenishByType(pType, pool, NO_LOAN_FEE, pmtA, AId, pmtB, BId, balA, balB, shareId) 
    strict (newBalA, newBalB) = getPoolBalances(Address(pool.fromBase58String()), pType, AId, BId)
    let prImpact = calcPriceImpact(balA, balB, newBalA, newBalB)
    let (wAmountA, wAmountB) = calcWithdrawLPFromPoolVirt(Address(pool.fromBase58String()), pType, shareId, userStaked)
    (replenishEntries(pool, user, userStaked, axlyFee, newPosNum, shareId, pType, false) 
    ++ getCursEntries(AId, BId, shareId, [wAmountA.toString(), wAmountB.toString()]),
    [prImpact, wAmountA, wAmountB]
    )
})

@Callable(i)
func withdraw(pool: String, posId: Int) = isActiveForUsers().valueOrElse({
  let pType = this.getString(kPool + pool).valueOrErrorMessage("Pool is not inited")
  if !isPoolActive(pool, pType) then throw("Pool not active at this moment") else
  withdrawToUser(i.caller.toString(), pool, posId.toString(), false)
})

@Callable(i) 
func createUpdateStopLoss(posId: Int, poolId: String, assetId: String, price: Int) = isActiveForUsers().valueOrElse({
  let tokenOraclePrice = priceOracleAddr.getIntegerValue(assetId + kPriceInOracle)
  let pType = this.getString(kPool + poolId).valueOrErrorMessage("Pool is not inited")
  if !isPoolActive(poolId, pType) then throw("Pool not active at this moment") else
  if !this.getInteger(poolId + "_" + i.caller.toString() + "_" + posId.toString() + kUserPosition).isDefined() then throw("There are no user position") else
  if price <= 0 then throw("Price must be greater than 0") else
  if tokenOraclePrice < price then throw("Price must be less than current token price") else
  [
    IntegerEntry(i.caller.toString() + "_" + posId.toString() + "_" + poolId + "_" + assetId + kUserStopLoss, price)
  ]
})

@Callable(i) 
func deleteStopLoss(posId: Int, poolId: String, assetId: String) = isActiveForUsers().valueOrElse({
  let pType = this.getString(kPool + poolId).valueOrErrorMessage("Pool is not inited")
  if !isPoolActive(poolId, pType) then throw("Pool not active at this moment") else
  if !this.getInteger(i.caller.toString() + "_" + posId.toString() + "_" + poolId + "_" + assetId + kUserStopLoss).isDefined() then throw("No entry") else
  [DeleteEntry(i.caller.toString() + "_" + posId.toString() + "_" + poolId + "_" + assetId + kUserStopLoss)]
})

@Callable(i)
func init(
  moneyBoxAddr: String, 
  sfFarmingAddr: String,
  lendAddr: String,
  priceOracleAddr: String,
  keeperExContract: String,
  wxSwapContract: String,
  swopAssetId: String,
  wxAssetId: String,
  operatorPubKey: String
) = isSelfCall(i).valueOrElse({
  if getString(kOperatorCallPK).isDefined() then throw("Already inited") else
  if !moneyBoxAddr.addressFromString().isDefined() then throw("moneyBoxAddr is not correct address") else
  if !sfFarmingAddr.addressFromString().isDefined() then throw("sfFarmingAddr is not correct address") else
  if !lendAddr.addressFromString().isDefined() then throw("lendAddr is not correct address") else
  if !priceOracleAddr.addressFromString().isDefined() then throw("priceOracleAddr is not correct address") else
  if !keeperExContract.addressFromString().isDefined() then throw("keeperExContract is not correct address") else
  if !swopAssetId.fromBase58String().assetInfo().isDefined() then throw("swopAssetId is not correct asset id") else
  if !wxAssetId.fromBase58String().assetInfo().isDefined() then throw("swopAssetId is not correct asset id") else
  if operatorPubKey.fromBase58String().size() != 32 then throw("operatorPubKey is not correct") else
  [
    StringEntry(kMoneyBox, moneyBoxAddr),
    StringEntry(kSFFarmingAddr, sfFarmingAddr),
    StringEntry(kLendService, lendAddr),
    StringEntry(kPriceOracle, priceOracleAddr),
    StringEntry(kExContract, keeperExContract),
    StringEntry(kWxSwapContract, wxSwapContract),
    StringEntry(kSwopId, swopAssetId),
    StringEntry(kWxId, wxAssetId),
    StringEntry(kOperatorCallPK, operatorPubKey)
  ]
})

########## Self call functions #######

@Callable(i)
func createNewRequest(params: String) = isSelfCall(i).valueOrElse({
  let newRequestId = this.getInteger(kRequestIter).valueOrElse(0) + 1
  (
    [
      StringEntry(newRequestId.toString() + kRequestId, params),
      IntegerEntry(kRequestIter, newRequestId)
    ], 
    newRequestId
  )
})

##########ADMIN FUNCTIONS###############

@Callable(i)
func replenishFromLand(requestId: String) = 
isActive().valueOrElse(
isLandCall(i).valueOrElse({
  let (user, pool, pmtA, AId, pmtB, BId, balA, balB, shareId, bwAsset, bwAmount) = parseRequest(requestId)
  if i.payments.size() != 1 then throw("Wrong payment size") else
  if assetIdToStr(i.payments[0].assetId) != bwAsset || i.payments[0].amount != bwAmount then throw("Wrong payment") else
  let (pmtAllA, pmtAllB) = if AId == bwAsset then (pmtA + bwAmount, pmtB) else (pmtA, pmtB + bwAmount)
  let pType = this.getString(kPool + pool).valueOrErrorMessage("Unknown pool")
  let (userStaked, axlyFee) = replenishByType(pType, pool, LOAN_FEE, pmtAllA, AId, pmtAllB, BId, balA, balB, shareId) 
  let posNum = getNewUserPositionNumber(user)
  let borrowEntries = [
    IntegerEntry(pool + "_"  + user + "_" + posNum.toString() + kUserBorrowAmount, bwAmount),
    StringEntry(pool + "_"  + user + "_" + posNum.toString() + kUserBorrowAssetId, bwAsset)
  ]
  let entries = replenishEntries(pool, user, userStaked, axlyFee, posNum, shareId, pType, true)
  let (wAmountA, wAmountB) = calcWithdrawLPFromPoolVirt(Address(pool.fromBase58String()), pType, shareId, userStaked)
  ( 
    entries ++ 
    getCursEntries(AId, BId, shareId, [wAmountA.toString(), wAmountB.toString()]) ++ 
    borrowEntries :+ 
    DeleteEntry(requestId + kRequestId), 
    userStaked
  )
}))

@Callable(i) 
func liquidate(user: String, posId: String, liquidateAmount: Int) = 
isActive().valueOrElse(
isLandCall(i).valueOrElse({
  let pool = this.getString(user + "_" + posId + kUserPositionPool).valueOrErrorMessage("no position")
  let pType = this.getString(kPool + pool).valueOrErrorMessage("Pool is not inited")
  let (AId, BId, balA, balB, shareId) = getPoolData(Address(pool.fromBase58String()), pType)
  let amount = unstakeLP(pool, pType, shareId, liquidateAmount)
  let borrowAmount = this.getIntegerValue(pool + "_" + user + "_" + posId + kUserBorrowAmount)
  let borrowAsset = this.getStringValue(pool + "_" + user + "_" + posId + kUserBorrowAssetId)
  let userCanWithdraw = userCanWithdrawShareCalc(user, pool, posId, borrowAmount > 0)
  if liquidateAmount > userCanWithdraw then throw("You can't liquidate more than user have") else
  if borrowAmount == 0 then throw("You can't liquidate position without borrow") else 
  [
    IntegerEntry(pool + "_" + user + "_" + posId + kUserPositionInterest, this.getIntegerValue(pool + kPoolInterestLoan)),
    IntegerEntry(pool + kPoolTotalLoan, getPoolTotalShareWithLoan(pool) - liquidateAmount),
    IntegerEntry(pool + kPoolTotal, getPoolTotalShare(pool) - liquidateAmount),
    IntegerEntry(pool + "_" + user + "_" + posId + kUserPosition, userCanWithdraw - liquidateAmount),
    ScriptTransfer(i.caller, amount, shareId.fromBase58String())
  ]
  
}))

@Callable(i) 
func stopLoss(user: String, posId: Int, pool: String, assetId: String) = 
isActive().valueOrElse(
isOperatorCall(i).valueOrElse({
  let tokenOraclePrice = priceOracleAddr.getIntegerValue(assetId + kPriceInOracle)
  let stopLossPrice = this.getInteger(user + "_" + posId.toString() + "_" + pool + "_" + assetId + kUserStopLoss).valueOrErrorMessage("No entry")
  if tokenOraclePrice > stopLossPrice then throw("Token price greater stop loss price") else
  let res = withdrawToUser(user, pool, posId.toString(), true)
   (
     res._1:+ DeleteEntry(user + "_" + posId.toString() + "_" + pool + "_" + assetId + kUserStopLoss),
     res._2
   )
}))

@Callable(i)
func capitalizeExKeeper(
  pool: String, 
  tokenToId: String, 
  amountToExchange: Int, 
  claim: Boolean,
  amountsIn: List[Int], 
  addresses: List[String], 
  assetsToReceive: List[String], 
  estReceived: List[Int], 
  slippageTolerance: Int, 
  minReceived: Int, 
  options: List[String]
) = 
isActive().valueOrElse(
isOperatorCall(i).valueOrElse({
  let pType = this.getStringValue(kPool + pool)
  let change = this.getInteger(pool + kPoolCapChange).valueOrElse(0)
  let (claimedAmount, claimedAsset) = claimAndCheckAmnt(pool, pType, claim, amountToExchange, change)
  let exchangedAmount = exchangeKeeper(tokenToId, amountToExchange, claimedAsset, amountsIn, addresses, assetsToReceive, estReceived, slippageTolerance, minReceived, options)
  let newChange = claimedAmount + change - amountToExchange
  let changeEntry = if newChange >= 0 then [IntegerEntry(pool + kPoolCapChange, newChange)] else throw("Negative change")
  capitalize(pool, pType, tokenToId, exchangedAmount) ++ changeEntry 
}))

@Callable(i)
func capitalizeExPuzzle(
  pool: String, 
  tokenToId: String,
  amountToExchange: Int, 
  claim: Boolean,
  routesStr: String, 
  minToReceive: Int,
  options: List[String]
) = 
isActive().valueOrElse(
isOperatorCall(i).valueOrElse({
  let pType = this.getStringValue(kPool + pool)
  let change = this.getInteger(pool + kPoolCapChange).valueOrElse(0)
  let (claimedAmount, claimedAsset) = claimAndCheckAmnt(pool, pType, claim, amountToExchange, change)
  let exchangedAmount = exchangePuzzle(tokenToId, amountToExchange, claimedAsset, routesStr,  minToReceive, options)
  let newChange = claimedAmount + change - amountToExchange
  let changeEntry = if newChange >= 0 then [IntegerEntry(pool + kPoolCapChange, newChange)] else []
  capitalize(pool, pType, tokenToId, exchangedAmount) ++ changeEntry
}))

@Callable(i)
func capitalizeExSwopFi(
  pool: String,  
  tokenToId: String,
  amountToExchange: Int, 
  claim: Boolean,
  exchangers: List[String],
  exchangersType: List[String],
  args1: List[String],
  args2: List[String],
  routingAssetsKeys: List[String],
  minAmountToReceive: Int,
  options: List[String]
) = 
isActive().valueOrElse(
isOperatorCall(i).valueOrElse({
  let pType = this.getStringValue(kPool + pool)
  let change = this.getInteger(pool + kPoolCapChange).valueOrElse(0)
  let (claimedAmount, claimedAsset) = claimAndCheckAmnt(pool, pType, claim, amountToExchange, change)
  let exchangedAmount = exchangeSwopFi(tokenToId, amountToExchange, claimedAsset, exchangers,exchangersType,args1,args2,routingAssetsKeys,minAmountToReceive,options)
  let newChange = claimedAmount + change - amountToExchange
  let changeEntry = if newChange >= 0 then [IntegerEntry(pool + kPoolCapChange, newChange)] else []
  capitalize(pool, pType, tokenToId, exchangedAmount) ++ changeEntry
}))

@Callable(i)
func capitalizeNoEx(pool: String, claim: Boolean, amountFromBalance: Int) = 
isActive().valueOrElse(
isOperatorCall(i).valueOrElse({
  let pType = this.getStringValue(kPool + pool)
  let (claimedAmount, claimedAsset) = claimAndCheckAmnt(pool, pType, claim, amountFromBalance, 0)
  capitalize(pool, pType, claimedAsset.assetIdToStr(), amountFromBalance)
}))

@Callable(i)
func initNewPool(type: String, poolAddr: String, inFeeNoLoan: Int, inFeeLoan: Int, capFeeNoLoan:Int, capFeeWithLoan:Int, stoplossFeeNoLoan:Int, stoplossFeeWithLoan:Int, canBorrow: Boolean) = 
isActive().valueOrElse(
isAdminCall(i).valueOrElse({
  if type != SF_POOL && type != WX_POOL then throw("Wrong type") else
  let (aId, bId, aBal, bBal, shareId) = getPoolData(poolAddr.fromBase58String().Address(), type)
  if inFeeNoLoan < 0 then throw("inFeeNoLoan must be greater than 0") else
  if inFeeLoan < 0 then throw("inFeeLoan must be greater than 0") else
  if capFeeNoLoan < 0 then throw("capFeeNoLoan must be greater than 0") else
  if capFeeWithLoan < 0 then throw("capFeeWithLoan must be greater than 0") else
  if stoplossFeeNoLoan < 0 then throw("stoplossFeeNoLoan must be greater than 0") else
  if stoplossFeeWithLoan < 0 then throw("stoplossFeeWithLoan must be greater than 0") else
  [
    IntegerEntry(poolAddr + kAxlyInFeeWithoutLoan, inFeeNoLoan),
    IntegerEntry(poolAddr + kAxlyInFeeWithLoan, inFeeLoan),
    IntegerEntry(poolAddr + kAxlyNoLoanCapFee, capFeeNoLoan),
    IntegerEntry(poolAddr + kAxlyWithLoanCapFee, capFeeWithLoan),
    IntegerEntry(poolAddr + kAxlyStopLossNoLoanFee, stoplossFeeNoLoan),
    IntegerEntry(poolAddr + kAxlyStopLossLoanFee, stoplossFeeWithLoan),
    IntegerEntry(poolAddr + kPoolInterestLoan, 0),
    IntegerEntry(poolAddr + kPoolInterestNoLoan, 0),
    StringEntry(kPool + poolAddr, type),
    StringEntry(shareId + kSharePool, poolAddr),
    BooleanEntry(poolAddr + kPoolCanBorrow, canBorrow)
  ]
}))

@Callable(i)
func activate() = isAdminCall(i).valueOrElse({
  if this.getBoolean(kActive).valueOrElse(true) then throw("dApp already active") else
  [BooleanEntry(kActive, true)]
})

@Callable(i)
func shutdown() = isAdminCall(i).valueOrElse({
  if !this.getBoolean(kActive).valueOrElse(true) then throw("dApp already shutdown") else
  [BooleanEntry(kActive, false)]
})

@Callable(i)
func activateForUsers() = isAdminCall(i).valueOrElse({
  if this.getBoolean(kActiveUsers).valueOrElse(true) then throw("dApp already active for users") else
  [BooleanEntry(kActiveUsers, true)]
})

@Callable(i)
func shutdownForUsers() = isAdminCall(i).valueOrElse({
  if !this.getBoolean(kActiveUsers).valueOrElse(true) then throw("dApp already shutdown for users") else
  [BooleanEntry(kActiveUsers, false)]
})

@Callable(i)
func activateSF() = isAdminCall(i).valueOrElse({
  if this.getBoolean(SF_POOL + kActiveSFWX).valueOrElse(true) then throw("SWOPFI already active") else
  [BooleanEntry(SF_POOL + kActiveSFWX, true)]
})

@Callable(i)
func shutdownSF() = isAdminCall(i).valueOrElse({
  if !this.getBoolean(SF_POOL + kActiveSFWX).valueOrElse(true) then throw("SWOPFI already shutdown") else
  [BooleanEntry(SF_POOL + kActiveSFWX, false)]
})

@Callable(i)
func activateWX() = isAdminCall(i).valueOrElse({
  if this.getBoolean(WX_POOL + kActiveSFWX).valueOrElse(true) then throw("WX already active") else
  [BooleanEntry(WX_POOL + kActiveSFWX, true)]
})

@Callable(i)
func shutdownWX() = isAdminCall(i).valueOrElse({
  if !this.getBoolean(WX_POOL + kActiveSFWX).valueOrElse(true) then throw("WX already shutdown") else
  [BooleanEntry(WX_POOL + kActiveSFWX, false)]
})

@Callable(i)
func activatePool(pool:String) = isAdminCall(i).valueOrElse({
  if !this.getString(kPool + pool).isDefined() then throw("Unknown pool") else
  if this.getBoolean(pool + kPoolActive).valueOrElse(true) then throw("Pool already active") else
  [BooleanEntry(pool + kPoolActive, true)]
})

@Callable(i)
func shutdownPool(pool:String) = isAdminCall(i).valueOrElse({
  if !this.getString(kPool + pool).isDefined() then throw("Unknown pool") else
  if !this.getBoolean(pool + kPoolActive).valueOrElse(true) then throw("Pool already shutdown") else
  [BooleanEntry(pool + kPoolActive, false)]
})

@Verifier(tx)
func verify() = {
    let multiSignedByAdmins = {
        let adminPubKey1Signed = if sigVerify(tx.bodyBytes, tx.proofs[0], admin1PK) then 1 else 0
        let adminPubKey2Signed = if sigVerify(tx.bodyBytes, tx.proofs[1], admin2PK) then 1 else 0
        adminPubKey1Signed + adminPubKey2Signed == 2
    }
    multiSignedByAdmins
}
